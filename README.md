----------------------------------------------------------------------------------------------Functions--------------------------------------------------------------------------------------------------

1. void mems init()------->
This function initialises everything required for the MeMs system. Head pointer is initialised with null and the flag for initial memory allocation is initialised with 0 as the free list is currently empty & initial memory block has not been allocated yet respectively. It then uses mmap system call to allocate the initial memory block. If mmap fails then a message is printed using perror and program exits. If it succeeds then the flag is set to 1 and "mem_start" points to start of allocated memory block.

2. void mems finish()----->
This function initialise a pointer "current" to head and then use a while loop to traverse the whole list using current. Variable next is used to store the value of the next node and then used to update the value of "current" pointer after each deallocation. We deallocate memory block which is pointed by each value of "current" pointer using munmap.

3. void* mems_malloc(size_t size)--------->
This function is used to allocate memory block of size given by the user. If the size is 0, it prints an error message. The function then traverses the whole list and looks for a hole whose size is big enough to satisfy the user request. If this hole is found, the hole indicating flag is set to 0(used) and virtual address of memory block is returned.
If we don't find a suitable hole then the function calculates the number of pages and total size (number of pages*page size) required to satisfy the request and uses the mmap system call to allocate a new memory block of total size calculated. If it fails, it prints an error message using perror otherwise a new node is created and all its information such as virtual address, physical address, size etc. is initialised. The new node is added to the beginning of the list and the variables for storing the virtual and physical addresses of the next available virtual and physical addresses respectively are updated to point to the next ones. Then the virtual address of the memory block is returned.

4. void mems_free(void* ptr)---------->
This function first traverses through the list and checks if for each node, virtual address of node matches the pointer given by the user, to find the memory block which needs to be deallocated. If the required node is found, it checks the value of the hole flag. If hole flag is 1, it prints an error message. If the value of hole flag is 0, it sets it to 1 which means this memory block can be used for memory allocation now and then returns. If no matching node is found for the given pointer then an error message is printed.

5. void mems_print_stats()----------->
This function first traverses throught the main chain and identifies the subchains in the main chain based on page value of each node (nodes having same page value are part of same subchain). For each subchain, it prints the range of virtual addresses covered by the subchain. It then calculates the total amount of unused memory and total number of pages by traversing through the list. For each block, if the hole flag is set to 1, its size contributes to unused_memory. It then prints the total pages used and the total unused memory. 
The length of the main chain is also printed (number of pages used in the main chain=its length). We then use an array to calculate the total length of the subchain by counting number of nodes associated with each page value. Each index in the array represents a page number and its value in the array gives the length of subchain. The length of the subchain is then printed in the form of an array.

6. void *mems_get(void*v_ptr)---------->
The function first traverses throught the list and for each node, it calculates the starting and ending virtual address of the memory block. If the pointer given by the user falls in the range(starting virtual address, ending virtual address) then it calculates the offset of the user pointer from the startig virtual address and adds the offset to the physical address of the memory block. This is the required physical address which is then returned to the user. If no matching node is found in the list for the user pointer then an error message is printed. 
